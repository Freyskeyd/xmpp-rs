extern crate futures;
extern crate tokio_core;
extern crate xmpp;
extern crate byteorder;


use std::str::FromStr;
use std::fmt::Debug;
use tokio_core::io::{Codec, EasyBuf};
use std::str;
use std::io::Write;
use std::io;
use std::net::SocketAddr;
use std::marker::PhantomData;
use tokio_core::io::Io;
use tokio_core::reactor::Core;
use tokio_core::net::TcpStream;
use futures::{Stream, Sink, Future};
use futures::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel(1);

    run_client(rx, tx, |ServerMessage(msg)| -> Option<ClientMessage> {
        if msg.len() > 1 {
            if msg.starts_with("<proceed") {
                return Some(ClientMessage("<auth".to_string()));
            }
        }
        None
    });
}


fn run_client<F>(rx: mpsc::Receiver<ClientMessage>, tx: mpsc::Sender<ClientMessage>, f: F) 
    where F: Fn(ServerMessage) -> Option<ClientMessage> + 'static
{
    let addr = "127.0.0.1:5222".parse::<SocketAddr>().unwrap();

    let mut core = Core::new().unwrap();
    let handle = core.handle();
    let tcp = TcpStream::connect(&addr, &handle);

    let handshake = tcp.and_then(|stream| {
        let handshake_io = stream.framed(HandshakeCodec::new(""));

        let start = "<?xml version='1.0'?><stream:stream version='1.0' xmlns:stream='http://etherx.jabber.org/streams' to='example.com' xmlns='jabber:client'>";
        handshake_io
            .send(start.to_string())
            .map(|handshake_io| handshake_io.into_inner())
    });

    let send_to_server = |msg| {
        match tx.clone().start_send(ClientMessage(msg)) {
            Ok(_) => println!("message sent"),
            Err(_) => println!("fail to send to sink")
        }
    };

    let client = handshake.and_then(|socket| {
        let (to_server, from_server) = socket.framed(ClientToServerCodec::new()).split();

        let reader = from_server
            .for_each(move |msg| {
                if msg.len() > 1 {
                    if msg.starts_with("<stream:features") {

                    let message = String::from("<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>");

                    send_to_server(message);
                    }
                }

                match f(msg) {
                    Some(ret) => send_to_server(ret),
                    None => {}
                };

                Ok(())
            });

        let writer = rx
            .map_err(|()| unreachable!("rx can't fail"))
            .fold(to_server, |to_server, msg| {
                to_server.send(msg)
            })
            .map(|_| ());

        reader.select(writer).map(|_| ()).map_err(|(err, _)| err)
    });

    core.run(client).unwrap();
}

use std::fmt;
#[derive(Debug, Clone)]
pub struct Handshake {
    pub name: String,
}

impl Handshake {
    pub fn new<S: Into<String>>(name: S) -> Handshake {
        Handshake { name: name.into() }
    }
}

pub type HandshakeCodec = LengthPrefixedJson<Handshake, Handshake>;

#[derive(Debug, Clone)]
pub struct ClientMessage(pub String);

impl ClientMessage {
    pub fn new<S: Into<String>>(message: S) -> ClientMessage {
        ClientMessage(message.into())
    }
}

impl std::fmt::Display for ClientMessage {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        write!(f, "{}", self.0)
    }
}

#[derive(Debug)]
pub struct ServerMessage(pub String);


pub struct LengthPrefixedJson<In, Out>
    where In: Debug + FromStr + ToString,
          Out: Debug + FromStr + ToString
{
    _in: PhantomData<In>,
    _out: PhantomData<Out>,
}

impl<In, Out> LengthPrefixedJson<In, Out>
    where In: Debug + FromStr + ToString,
          Out: Debug + FromStr + ToString
{
    pub fn new() -> LengthPrefixedJson<In, Out> {
        LengthPrefixedJson {
            _in: PhantomData,
            _out: PhantomData,
        }
    }
}


impl<In, Out> Codec for LengthPrefixedJson<In, Out>
    where In: ToString + FromStr + Debug,
          Out: ToString + FromStr + Debug
{
    type In = In;
    type Out = Out;

    fn decode(&mut self, buf: &mut EasyBuf) -> io::Result<Option<Self::In>> {
        let len = buf.len();
        if len < 1 {
            return Ok(None);
        }

        let buf = buf.drain_to(len);
        let s = str::from_utf8(buf.as_slice()).unwrap();

        println!("IN: {:?}", s);
        match In::from_str(s) {
            Ok(s) => Ok(Some(s)),
            Err(_) => Ok(None)
        }
    }

    fn encode(&mut self, msg: Out, buf: &mut Vec<u8>) -> io::Result<()> {
        println!("OUT: {:?}", msg);
        let _ = buf.write(msg.to_string().as_bytes());

        Ok(())
    }
}


// // Enumerate possible messages the server can send to clients.
// #[derive(Serialize, Deserialize, Debug, Clone)]
// pub enum ServerMessage {
//     // A message from a client (first String) containing arbitrary content (second String).
//     Message(String, String),

//     // Notification of a new user connection. The associated String is the name that user provided
//     // in their Handshake.
//     UserConnected(String),
//     //
//     // Notification of user disconnection. The associated String is the name that user provided
//     // in their Handshake.
//     UserDisconnected(String),
// }

pub type ServerToClientCodec = LengthPrefixedJson<ClientMessage, ServerMessage>;
pub type ClientToServerCodec = LengthPrefixedJson<ServerMessage, ClientMessage>;

impl FromStr for ClientMessage {
    type Err = ();
    fn from_str(s: &str) -> Result<ClientMessage, ()> {
        Ok(ClientMessage::new(s))
    }
}
impl std::fmt::Display for ServerMessage {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        write!(f, "{}", self.0)
    }
}

